package myCBR;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Queue;
import java.util.Set;

import model.Case;
import model.Request;
import model.Situation;
import de.dfki.mycbr.core.DefaultCaseBase;
import de.dfki.mycbr.core.Project;
import de.dfki.mycbr.core.casebase.Attribute;
import de.dfki.mycbr.core.casebase.Instance;
import de.dfki.mycbr.core.model.AttributeDesc;
import de.dfki.mycbr.core.model.BooleanDesc;
import de.dfki.mycbr.core.model.Concept;
import de.dfki.mycbr.core.model.IntegerDesc;
import de.dfki.mycbr.core.model.StringDesc;
import de.dfki.mycbr.core.model.SymbolDesc;
import de.dfki.mycbr.core.retrieval.Retrieval;
import de.dfki.mycbr.core.retrieval.Retrieval.RetrievalMethod;
import de.dfki.mycbr.core.similarity.AmalgamationFct;
import de.dfki.mycbr.core.similarity.Similarity;
import de.dfki.mycbr.util.Pair;

/**
 * @author the cbr team & Daniel Schreider
 */

public class Recommender {

	public CBREngine engine;
	public Project project;
	public DefaultCaseBase cb;
	public Concept myConcept;

	IntegerDesc trainCardsCount;
	
	public void loadengine(Request request) {

		engine = new CBREngine();
		project = engine.createProjectFromPRJ();
		// create case bases and assign the case bases that will be used for submitting
		// a query
		cb = (DefaultCaseBase) project.getCaseBases().get(engine.getCaseBase());
		// create a concept and get the main concept of the project;
		myConcept = project.getConceptByID(engine.getConceptName());

		trainCardsCount = (IntegerDesc) myConcept.getAllAttributeDescs().get("trainCardsCount");
//		
	}

//	public void CheckforAmalgamSelection(){
//
//		List<AmalgamationFct> liste = remy.myConcept.getAvailableAmalgamFcts();
//
//		for (int i = 0; i < liste.size(); i++){
//
//			if  ((liste.get(i).getName()).equals(InputAmalgam.getText())) {
//
//				remy.myConcept.setActiveAmalgamFct(liste.get(i));
//			}		 
//		}			
//	}

//	public Response solveOuery(Integer noun, Integer pluralnoun, String sentenceStructure, String keyword,
//			String keyword2, String verb, String verb2, Integer caseNumber) {
	public String solveOuery(Request request) {

//		public String displayAmalgamationFunctions() {
//
//			ArrayList<String> amalgam = new ArrayList<String>();
//			String listoffunctions = "Currently available Amalgamationfunctions: <br /> <br />";
//			AmalgamationFct current = myConcept.getActiveAmalgamFct();
//			System.out.println("Amalgamation Function is used = " + current.getName());
//			List<AmalgamationFct> liste = myConcept.getAvailableAmalgamFcts();
//
//			for (int i = 0; i < liste.size(); i++) {
////				System.out.println(liste.get(i).getName());
//				listoffunctions = listoffunctions + liste.get(i).getName() + "<br />";
//			}
//
//			listoffunctions = listoffunctions
//					+ (" <br /> <br /> Currently selected Amalgamationfunction: " + current.getName() + "\n");
//			listoffunctions = listoffunctions
//					+ (" <br /> <br /> Please type the name of the Amalgamationfunction to use in the "
//							+ " Field \"Amalgamationfunction\" it will be automatically used during the next retrieval");
////			System.out.println(listoffunctions);	 s
//			return listoffunctions;
//		}

		// answer -> response
//		String answer = "";
//		Response response = new Response();
		System.out.println("\n- Started the Retrieval -");
		// cbr team START
		// create a new retrieval
		Retrieval ret = new Retrieval(myConcept, cb);
		// specify the retrieval method
		ret.setRetrievalMethod(RetrievalMethod.RETRIEVE_SORTED);
		// specify the Amalgamationfunction (Fight - Reward - Andor)
		
		// create a query instance
		Instance query = ret.getQueryInstance();
		// cbr team END
//		try {
//			if (request.getRequestType().equalsIgnoreCase("RetrievalAndorComplete") || 
//					request.getRequestType().equalsIgnoreCase("RetrievalAndorRandom"))
//				query = fillInstanceComplete(query, request.getSituationComplete());
//			else
//				query = fillInstance(query, request.getSituation());
//		} catch (Exception e) {
//			e.printStackTrace();
//			System.out.println("Recommender: " + e.getMessage());
//		}
		
		try {
			query = fillInstance(query, request.getSituation());
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println(e.getMessage());
		}
		
//		String answerAttribute = "";
//		if (request.getRequestType().equalsIgnoreCase("Strategy")) {
//			answerAttribute = "strategy";
//		} else {
//			answerAttribute = "plan";
//		}
		StringDesc answerDesc = (StringDesc) myConcept.getAllAttributeDescs().get("plan");

		// measure performance time

		// perform retrieval
		ret.start();
		// get the retrieval result
		List<Pair<Instance, Similarity>> result = ret.getResult();

		double sim = 0;
		String answerAsString = "";	
		Map<Instance, Double> answers = new LinkedHashMap<>();	
		int answersCount = 5;
		Boolean done = false;
		int counter = 0;
		int instancesCount = cb.getCases().size();
		System.out.println("Number of instances of the casebase " + cb.getName() + ": " + instancesCount);
		if (instancesCount == 0) {
			return "";
		}
		if (result.size() > 0) {

			// get the best case's name
			String casename = result.get(0).getFirst().getName();
//			// get the similarity value
			Double simAll = result.get(0).getSecond().getValue();
//			// runde die Ähnlichkeit
			sim = Math.round(simAll * 100.0) / 100.0;
//			answer = "I found "+casename+" with a similarity of "+sim+" as the best match.";
//			answer = answer+"The "+numberofcases+" best cases shown in a table: <br /> <br /> <table border=\"1\">";	
			ArrayList<Hashtable<String, String>> liste = new ArrayList<Hashtable<String, String>>();
//			// if more case results are requested than we have in our case base at all:
//			if(numberofcases>=cb.getCases().size()){numberofcases = cb.getCases().size();}
//
//			for (int i = 0; i <= caseNumber; i++) {

//			for (int i = 0; i < 5; i++) {
//
//				liste.add(getAttributes(result.get(i), rec.getConceptByID(engine.getConceptName())));
////				System.out.println("Fall: " + liste.get(i).toString());
////				answer=answer+"<tr><td>"+result.get(i).getFirst().getName()+"</td><td>"+liste.get(i).toString()+"</td></tr>";
//			}
//
//			answer= answer+"</table>";	
			
//			System.out.println("ResultNumber: " + result.size());
			
			if (request.getSituation() == null)
				request.setSituation(new Situation());

			answerAsString = result.get(counter).getFirst().getAttForDesc(answerDesc).getValueAsString();
			answerDesc = (StringDesc) myConcept.getAllAttributeDescs().get(answerAsString);

		
//		if (answers.size() == 1) {
//			int count = 3;
//			for (Entry<Instance, Double> entry : answers.entrySet()) {
//				System.out.println("\nCase retrieved: " + entry.getKey().getAttForDesc(answerDesc).getValueAsString() 
//						+ " (" + entry.getKey() + ") with sim of " + entry.getValue());
//				answerAsString = entry.getKey().getAttForDesc(answerDesc).getValueAsString();
//			}
//			System.out.println("\nNext " + count + " cases would be: ");
//			if (instancesCount > 3) {
//				if (request.getRequestType().contains("RetrievalAndorComplete")) {
//					if (!request.getSituationComplete().situationType.equalsIgnoreCase("AndorComplete") &&
//							!request.getSituationComplete().situationType.equalsIgnoreCase("AndorRandom"))
//						count = 0;
//				} else {
//					if (!request.getSituation().situationType.equalsIgnoreCase("Andor"))
//						count = 0;
//				}
//				for (int i = 0; i < count; i++) {
//					if (result.get(counter+i).getFirst().getAttForDesc(answerDesc) == null)
//						continue; 
//					System.out.println("case: " + result.get(counter+i).getFirst().getAttForDesc(answerDesc).getValueAsString() 
//							+ " (" + result.get(counter+i-1).getFirst().getName() + ") with Sim: "+ result.get(counter+i-1).getSecond().getValue());
//				}
//			}
//		} else {
//			Map.Entry<Instance, Double> randomCase = chooseRandomCase(answers);
//			answerAsString = randomCase.getKey().getAttForDesc(answerDesc).getValueAsString();
//			int count = 3;
//			System.out.println("\nCases with same Similarity were retrieved. Random chosen case: " 
//			+ randomCase.getKey().getAttForDesc(answerDesc).getValueAsString() + " (" + randomCase.getKey() + 
//			") with sim of " + randomCase.getValue());
//			System.out.println("\nAll cases in this list: ");
//			for (Entry<Instance, Double> entry : answers.entrySet()) {
//				System.out.println("case: " + entry.getKey().getAttForDesc(answerDesc).getValueAsString() 
//						+ " (" + entry.getKey() + ") with Sim: "+ entry.getValue());
//			}
//			System.out.println("\nNext " + count + " cases would be: ");
//			if (instancesCount > 3) {
//				if (request.getRequestType().contains("RetrievalAndorComplete")) {
//					if (!request.getSituationComplete().situationType.equalsIgnoreCase("AndorComplete") &&
//							!request.getSituationComplete().situationType.equalsIgnoreCase("AndorRandom"))
//						count = 0;
//				} else {
//					if (!request.getSituation().situationType.equalsIgnoreCase("Andor"))
//						count = 0;
//				}
//				for (int i = 0; i < count; i++) {
//					System.out.println("case: " + result.get(counter+i).getFirst().getAttForDesc(answerDesc).getValueAsString() 
//							+ " (" + result.get(counter+i-1).getFirst().getName() + ") with Sim: "+ result.get(counter+i-1).getSecond().getValue());
//				}
//			}
		}
		return answerAsString;
	}

	private Instance fillInstance(Instance instance, Situation situation) throws ParseException {

		instance.addAttribute(trainCardsCount, trainCardsCount.getAttribute(situation.trainCardsCount));

		return instance;
	}

	public void insertNewCase(Case newCase) {

		try {
			System.out.println("Groesse der Fallbasis (" + cb.getName() + "): " + cb.getCases().size());
			String nameOfNewCase = "";
		    nameOfNewCase = (cb.getCases().size() + 1);
//		    nameOfNewCase = newCase.situation.playerHeroColor + (cb.getCases().size() + 1);
			
			Boolean nameOfCaseDone = false;
			int nameCounter = 2;
			String caseName = "";
			do {
				nameOfCaseDone = true;
				for (Iterator<Instance> iterator = cb.getCases().iterator(); iterator.hasNext();) {
					caseName = iterator.next().getName();
					if (nameOfNewCase.equals(caseName)) {
						nameOfCaseDone = false;
						nameOfNewCase = nameCounter + "";
//						nameOfNewCase = newCase.situation.playerHeroColor + nameCounter;
						nameCounter++;
					}
				}
			} while (!nameOfCaseDone);

			Instance caseToInsert = myConcept.addInstance(nameOfNewCase);

			caseToInsert = fillInstance(caseToInsert, newCase.situation);


			caseToInsert.addAttribute(plan, plan.getAttribute(newCase.plan));
			cb.addCase(caseToInsert);

			System.out.println("Fall hinzugefuegt: " + nameOfNewCase);
			System.out.println("Groesse der Fallbasis (" + cb.getName() +  ") nach Hinzufuegen des Falls: " + cb.getCases().size());

			project.getCaseBases().get("AllCases").addCase(caseToInsert);

			project.save();

		} catch (Exception exc) {
			System.out.println("Exception!");
			System.out.println(exc.getMessage());
		}
	}

	public Map.Entry<Instance, Double> evaluateCasesByUtility(Map<Instance, Double> answers) {
		Map.Entry<Instance, Double> bestCase = answers.entrySet().iterator().next();
		for (Entry<Instance, Double> entry : answers.entrySet()) {
			if (Integer.parseInt(entry.getKey().getAttForDesc(utility).getValueAsString()) > 
				Integer.parseInt(bestCase.getKey().getAttForDesc(utility).getValueAsString())) {
				bestCase = entry;
			} else if (Integer.parseInt(entry.getKey().getAttForDesc(utility).getValueAsString()) 
				== Integer.parseInt(bestCase.getKey().getAttForDesc(utility).getValueAsString())) {
				if (Math.round(Math.random()) == 1)
					bestCase = entry;
			}
		}
		
		return bestCase;
	}
	
	public Map.Entry<Instance, Double> chooseRandomCase(Map<Instance, Double> answers) {
		int random = (int) (Math.random() * answers.size()-1);
		Map.Entry<Instance, Double> randomCase = (Entry<Instance, Double>) answers.entrySet().toArray()[random];
		return randomCase;
	}
	
	public Map.Entry<Instance, Double> evaluateCasesByUtilityUsingProbability(Map<Instance, Double> answers) {
		Map.Entry<Instance, Double> bestCase = answers.entrySet().iterator().next();
		return bestCase;
	}
	
//	Attribute utilityDesc = caseEntry.getKey().getAttForDesc(utility);
//	int utility = Integer.parseInt(utilityDesc.getValueAsString()
	
	public void decreaseCaseBase(DefaultCaseBase cb, int limit) {
		while (cb.getCases().size() > limit) {
			Boolean allCasesHavePositiveUtility = true;
			for (Instance c : cb.getCases()) {
				if (Integer.parseInt(c.getAttForDesc(utility).getValueAsString()) < 0) {
					allCasesHavePositiveUtility = false;
					break;
				}
			}
			
			if (allCasesHavePositiveUtility) {
				System.out.println("\nNo case was deleted. All cases have positive utility!");
				return;
			}
			
			Instance caseToDelete = cb.getCases().iterator().next();
			for (Instance c : cb.getCases()) {			
				if (Integer.parseInt(c.getAttForDesc(utility).getValueAsString()) < 
						Integer.parseInt(caseToDelete.getAttForDesc(utility).getValueAsString())) {
					caseToDelete = c;
				} else if (Integer.parseInt(c.getAttForDesc(utility).getValueAsString()) == 
						Integer.parseInt(caseToDelete.getAttForDesc(utility).getValueAsString())) {
					if (Math.round(Math.random()) == 1)
						caseToDelete = c;
				}
			}
			cb.removeCase(caseToDelete);
			System.out.println("Case " + caseToDelete.getAttForDesc(plan).getValueAsString() + " (" + caseToDelete.getName() 
				+ ") with utility of " + caseToDelete.getAttForDesc(utility).getValueAsString() + " was removed from the case base.");
			project.save();
		}
	}
	
	/**
	 * Diese Methode befuellt eine gegebene Instanz mit den konkreten Werten, die
	 * aus einem gegebenen Status gezogen werden k&ouml;nnen.
	 * 
	 * @param instance Die Instanz, die befuellt werden soll.
	 * @param status   Der Status, aus dem die konkreten Werte gezogen werden.
	 * @return Die nun befuellte Instanz.
	 * @throws ParseException
	 */
//	private Instance fillQueryPrototype(Instance instance, Status status, String player, String requestType) throws ParseException {
//
////			if (player.equals("Player1")) {
////				status.calculatePreferencePlayer1();
////			} else {
////				status.calculatePreferencePlayer2();
////			}
//		//jtf.setText(jtf.getText() + "\n*******************Preference: " + status.getPreference());
//		
//		// Die folgenden Zeilen ersetzen diesen Code:
////		IntegerDesc availableBrickDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableBrick");
////		query.addAttribute(availableBrickDesc, availableBrickDesc.getAttribute(request.getSituation().getPlayerStatus().brick));
//		
//		
//		if (requestType.equalsIgnoreCase("Turn")) {
//			IntegerDesc availableBrickDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableBrick");
//			IntegerDesc availableWoodDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableWood");
//			IntegerDesc availableWheatDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableWheat");
//			IntegerDesc availableSheepDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableSheep");
//			IntegerDesc availableStoneDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableStone");
//			IntegerDesc handcardsCountDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("handcardsCount");
//			
//			IntegerDesc probabilityBrickDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("probabilityBrick");
//			IntegerDesc probabilityWoodDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("probabilityWood");
//			IntegerDesc probabilityWheatDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("probabilityWheat");
//			IntegerDesc probabilitySheepDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("probabilitySheep");
//			IntegerDesc probabilityStoneDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("probabilityStone");
//			
//			IntegerDesc availableHarborBrickDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableHarborBrick");
//			IntegerDesc availableHarborWoodDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableHarborWood");
//			IntegerDesc availableHarborWheatDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableHarborWheat");
//			IntegerDesc availableHarborSheepDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableHarborSheep");
//			IntegerDesc availableHarborStoneDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableHarborStone");
//			
//			IntegerDesc devCardKnightIsAvailableDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("devCardKnightIsAvailable");
//			IntegerDesc devCardMonopolyIsAvailableDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("devCardMonopolyIsAvailable");
//			IntegerDesc devCardRoadBuildingIsAvailableDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("devCardRoadBuildingIsAvailable");
//			IntegerDesc devCardYearOfPlentyIsAvailableDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("devCardYearOfPlentyIsAvailable");
//			
//			IntegerDesc knightCountOpDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("knightCountOp");
//			IntegerDesc knightCountOwnDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("knightCountOwn");		
//			IntegerDesc largestArmyIsOwnerDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("largestArmyIsOwner");
//			
//			IntegerDesc longestRoadOpDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("longestRoadOp");
//			IntegerDesc longestRoadOwnDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("longestRoadOwn");
//			IntegerDesc longestRoadIsOwnerDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("longestRoadIsOwner");
//			
//			IntegerDesc thiefIsBlockingDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("thiefIsBlocking");
//			IntegerDesc victoryPointsOpDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("victoryPointsOp");
//			IntegerDesc victoryPointsOwnDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("victoryPointsOwn");
//			
//			IntegerDesc villagePlaceAvailableDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("villagePlaceAvailable");
//			IntegerDesc villagePlaceTargetAvailableDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("villagePlaceTargetAvailable");
//			IntegerDesc cityPlaceAvailableDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("cityPlaceAvailable");
//			IntegerDesc cityPlaceTargetAvailableDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("cityPlaceTargetAvailable");
//			IntegerDesc roadPlaceAvailableDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("roadPlaceAvailable");
//			IntegerDesc roadPlaceTargetAvailableDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("roadPlaceTargetAvailable");
//			
//			IntegerDesc roadsRequiredDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("roadsRequired");
//			SymbolDesc currentStrategyDesc = (SymbolDesc) myConcept.getAllAttributeDescs().get("currentStrategy");
////			IntegerDesc villagesDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("villages");
//			
//			instance.addAttribute(availableBrickDesc, availableBrickDesc.getAttribute(status.brick));
//			instance.addAttribute(availableWoodDesc, availableWoodDesc.getAttribute(status.wood));
//			instance.addAttribute(availableWheatDesc, availableWheatDesc.getAttribute(status.wheat));
//			instance.addAttribute(availableSheepDesc, availableSheepDesc.getAttribute(status.sheep));
//			instance.addAttribute(availableStoneDesc, availableStoneDesc.getAttribute(status.stone));
//			instance.addAttribute(handcardsCountDesc, handcardsCountDesc.getAttribute(status.handcardsCount));
//			
//			instance.addAttribute(probabilityBrickDesc, probabilityBrickDesc.getAttribute(status.probabilityBrick));
//			instance.addAttribute(probabilityWoodDesc, probabilityWoodDesc.getAttribute(status.probabilityWood));
//			instance.addAttribute(probabilityWheatDesc, probabilityWheatDesc.getAttribute(status.probabilityWheat));
//			instance.addAttribute(probabilitySheepDesc, probabilitySheepDesc.getAttribute(status.probabilitySheep));
//			instance.addAttribute(probabilityStoneDesc, probabilityStoneDesc.getAttribute(status.probabilityStone));
//			
//			instance.addAttribute(availableHarborBrickDesc, availableHarborBrickDesc.getAttribute(status.availableHarborBrick));
//			instance.addAttribute(availableHarborWoodDesc, availableHarborWoodDesc.getAttribute(status.availableHarborWood));
//			instance.addAttribute(availableHarborWheatDesc, availableHarborWheatDesc.getAttribute(status.availableHarborWheat));
//			instance.addAttribute(availableHarborSheepDesc, availableHarborSheepDesc.getAttribute(status.availableHarborSheep));
//			instance.addAttribute(availableHarborStoneDesc, availableHarborStoneDesc.getAttribute(status.availableHarborStone));
//			
//			instance.addAttribute(devCardKnightIsAvailableDesc, devCardKnightIsAvailableDesc.getAttribute(status.devCardKnightIsAvailable));
//			instance.addAttribute(devCardMonopolyIsAvailableDesc, devCardMonopolyIsAvailableDesc.getAttribute(status.devCardMonopolyIsAvailable));
//			instance.addAttribute(devCardRoadBuildingIsAvailableDesc, devCardRoadBuildingIsAvailableDesc.getAttribute(status.devCardRoadBuildingIsAvailable));
//			instance.addAttribute(devCardYearOfPlentyIsAvailableDesc, devCardYearOfPlentyIsAvailableDesc.getAttribute(status.devCardYearOfPlentyIsAvailable));
//			
//			instance.addAttribute(knightCountOpDesc, knightCountOpDesc.getAttribute(status.knightCountOp));
//			instance.addAttribute(knightCountOwnDesc, knightCountOwnDesc.getAttribute(status.knightCountOwn));
//			instance.addAttribute(largestArmyIsOwnerDesc, largestArmyIsOwnerDesc.getAttribute(status.largestArmyIsOwner));
//			
//			instance.addAttribute(longestRoadOpDesc, longestRoadOpDesc.getAttribute(status.longestRoadOp));
//			instance.addAttribute(longestRoadOwnDesc, longestRoadOwnDesc.getAttribute(status.longestRoadOwn));
//			instance.addAttribute(longestRoadIsOwnerDesc, longestRoadIsOwnerDesc.getAttribute(status.longestRoadIsOwner));
//			
//			instance.addAttribute(thiefIsBlockingDesc, thiefIsBlockingDesc.getAttribute(status.thiefIsBlocking));
//			instance.addAttribute(victoryPointsOpDesc, victoryPointsOpDesc.getAttribute(status.victoryPointsOp));
//			instance.addAttribute(victoryPointsOwnDesc, victoryPointsOwnDesc.getAttribute(status.victoryPointsOwn));
//			
//			instance.addAttribute(villagePlaceAvailableDesc, villagePlaceAvailableDesc.getAttribute(status.villagePlaceAvailable));
//			instance.addAttribute(villagePlaceTargetAvailableDesc, villagePlaceTargetAvailableDesc.getAttribute(status.villagePlaceTargetAvailable));
//			instance.addAttribute(cityPlaceAvailableDesc, cityPlaceAvailableDesc.getAttribute(status.cityPlaceAvailable));
//			instance.addAttribute(cityPlaceTargetAvailableDesc, cityPlaceTargetAvailableDesc.getAttribute(status.cityPlaceTargetAvailable));
//			instance.addAttribute(roadPlaceAvailableDesc, roadPlaceAvailableDesc.getAttribute(status.roadPlaceAvailable));
//			instance.addAttribute(roadPlaceTargetAvailableDesc, roadPlaceTargetAvailableDesc.getAttribute(status.roadPlaceTargetAvailable));
//			
//			instance.addAttribute(roadsRequiredDesc, roadsRequiredDesc.getAttribute(status.roadsRequired));
//			instance.addAttribute(currentStrategyDesc, currentStrategyDesc.getAttribute(status.currentStrategy));
//			
//		} else {
//			
//			IntegerDesc probabilityBrickDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("probabilityBrick");
//			IntegerDesc probabilityWoodDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("probabilityWood");
//			IntegerDesc probabilityWheatDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("probabilityWheat");
//			IntegerDesc probabilitySheepDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("probabilitySheep");
//			IntegerDesc probabilityStoneDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("probabilityStone");
//			
//			IntegerDesc availableHarborBrickDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableHarborBrick");
//			IntegerDesc availableHarborWoodDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableHarborWood");
//			IntegerDesc availableHarborWheatDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableHarborWheat");
//			IntegerDesc availableHarborSheepDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableHarborSheep");
//			IntegerDesc availableHarborStoneDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableHarborStone");
//			
//			IntegerDesc knightCountOpDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("knightCountOp");
//			IntegerDesc knightCountOwnDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("knightCountOwn");		
//			IntegerDesc largestArmyIsOwnerDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("largestArmyIsOwner");
//			
//			IntegerDesc longestRoadOpDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("longestRoadOp");
//			IntegerDesc longestRoadOwnDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("longestRoadOwn");
//			IntegerDesc longestRoadIsOwnerDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("longestRoadIsOwner");
//			
//			IntegerDesc victoryPointsOpDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("victoryPointsOp");
//			IntegerDesc victoryPointsOwnDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("victoryPointsOwn");
//			
//			IntegerDesc villageCountDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("villageCount");
//			IntegerDesc cityCountDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("cityCount");
//			IntegerDesc roadCountDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("roadCount");
//			
//			IntegerDesc distanceToHarborBrickDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToHarborBrick");
//			IntegerDesc distanceToHarborWoodDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToHarborWood");
//			IntegerDesc distanceToHarborWheatDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToHarborWheat");
//			IntegerDesc distanceToHarborSheepDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToHarborSheep");
//			IntegerDesc distanceToHarborStoneDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToHarborStone");
//			
//			IntegerDesc distanceToVillageBuildPlaceBrickDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToVillageBuildPlaceBrick");
//			IntegerDesc distanceToVillageBuildPlaceWoodDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToVillageBuildPlaceWood");
//			IntegerDesc distanceToVillageBuildPlaceWheatDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToVillageBuildPlaceWheat");
//			IntegerDesc distanceToVillageBuildPlaceSheepDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToVillageBuildPlaceSheep");
//			IntegerDesc distanceToVillageBuildPlaceStoneDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToVillageBuildPlaceStone");
//			IntegerDesc distanceToVillageBuildPlaceBestDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToVillageBuildPlaceBest");
//			IntegerDesc distanceToVillageBuildPlaceGoodDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("distanceToVillageBuildPlaceGood");
//			
//			
//			instance.addAttribute(probabilityBrickDesc, probabilityBrickDesc.getAttribute(status.probabilityBrick));
//			instance.addAttribute(probabilityWoodDesc, probabilityWoodDesc.getAttribute(status.probabilityWood));
//			instance.addAttribute(probabilityWheatDesc, probabilityWheatDesc.getAttribute(status.probabilityWheat));
//			instance.addAttribute(probabilitySheepDesc, probabilitySheepDesc.getAttribute(status.probabilitySheep));
//			instance.addAttribute(probabilityStoneDesc, probabilityStoneDesc.getAttribute(status.probabilityStone));
//			
//			instance.addAttribute(availableHarborBrickDesc, availableHarborBrickDesc.getAttribute(status.availableHarborBrick));
//			instance.addAttribute(availableHarborWoodDesc, availableHarborWoodDesc.getAttribute(status.availableHarborWood));
//			instance.addAttribute(availableHarborWheatDesc, availableHarborWheatDesc.getAttribute(status.availableHarborWheat));
//			instance.addAttribute(availableHarborSheepDesc, availableHarborSheepDesc.getAttribute(status.availableHarborSheep));
//			instance.addAttribute(availableHarborStoneDesc, availableHarborStoneDesc.getAttribute(status.availableHarborStone));
//			
//			instance.addAttribute(knightCountOpDesc, knightCountOpDesc.getAttribute(status.knightCountOp));
//			instance.addAttribute(knightCountOwnDesc, knightCountOwnDesc.getAttribute(status.knightCountOwn));
//			instance.addAttribute(largestArmyIsOwnerDesc, largestArmyIsOwnerDesc.getAttribute(status.largestArmyIsOwner));
//			
//			instance.addAttribute(longestRoadOpDesc, longestRoadOpDesc.getAttribute(status.longestRoadOp));
//			instance.addAttribute(longestRoadOwnDesc, longestRoadOwnDesc.getAttribute(status.longestRoadOwn));
//			instance.addAttribute(longestRoadIsOwnerDesc, longestRoadIsOwnerDesc.getAttribute(status.longestRoadIsOwner));
//			
//			instance.addAttribute(victoryPointsOpDesc, victoryPointsOpDesc.getAttribute(status.victoryPointsOp));
//			instance.addAttribute(victoryPointsOwnDesc, victoryPointsOwnDesc.getAttribute(status.victoryPointsOwn));
//			
//			instance.addAttribute(villageCountDesc, victoryPointsOwnDesc.getAttribute(status.villageCount));
//			instance.addAttribute(cityCountDesc, victoryPointsOwnDesc.getAttribute(status.cityCount));
//			instance.addAttribute(roadCountDesc, victoryPointsOwnDesc.getAttribute(status.roadCount));
//			
//			instance.addAttribute(distanceToHarborBrickDesc, victoryPointsOwnDesc.getAttribute(status.distanceToHarborBrick));
//			instance.addAttribute(distanceToHarborWoodDesc, victoryPointsOwnDesc.getAttribute(status.distanceToHarborWood));
//			instance.addAttribute(distanceToHarborWheatDesc, victoryPointsOwnDesc.getAttribute(status.distanceToHarborWheat));
//			instance.addAttribute(distanceToHarborSheepDesc, victoryPointsOwnDesc.getAttribute(status.distanceToHarborSheep));
//			instance.addAttribute(distanceToHarborStoneDesc, victoryPointsOwnDesc.getAttribute(status.distanceToHarborStone));
//			
//			instance.addAttribute(distanceToVillageBuildPlaceBestDesc, victoryPointsOwnDesc.getAttribute(status.distanceToVillageBuildPlaceBest));
//			instance.addAttribute(distanceToVillageBuildPlaceGoodDesc, victoryPointsOwnDesc.getAttribute(status.distanceToVillageBuildPlaceGood));
//			instance.addAttribute(distanceToVillageBuildPlaceBrickDesc, victoryPointsOwnDesc.getAttribute(status.distanceToVillageBuildPlaceBrick));
//			instance.addAttribute(distanceToVillageBuildPlaceWoodDesc, victoryPointsOwnDesc.getAttribute(status.distanceToVillageBuildPlaceWood));
//			instance.addAttribute(distanceToVillageBuildPlaceWheatDesc, victoryPointsOwnDesc.getAttribute(status.distanceToVillageBuildPlaceWheat));
//			instance.addAttribute(distanceToVillageBuildPlaceSheepDesc, victoryPointsOwnDesc.getAttribute(status.distanceToVillageBuildPlaceSheep));
//			instance.addAttribute(distanceToVillageBuildPlaceStoneDesc, victoryPointsOwnDesc.getAttribute(status.distanceToVillageBuildPlaceStone));
//			
////			instance.addAttribute(villagesDesc, villagesDesc.getAttribute(status.villages));IntegerDesc availableBrickDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("availableBrick");
//		}
//		return instance;
//		
//	}

	// updateAttributeWeight(status);
	// tempStati.add(status);

	// temporary disabled
	/*
	 * setWeightForAttr(instance, RetrievalHelper.IS_COVERED_DESC, isCoveredAttrW);
	 * setWeightForAttr(instance, RetrievalHelper.PLAN_DESC, planAttrW);
	 * setWeightForAttr(instance, RetrievalHelper.QUALITY_DESC, qualityAttrW);
	 */

	// Alle Werte werden hier initial gesetzt.
	/*
	 * setWeightForAttr(instance, RetrievalHelper.IS_ABLED_TO_BUILD_CITY,
	 * isAbledToBuildCity); setWeightForAttr(instance,
	 * RetrievalHelper.IS_ABLED_TO_BUILD_VILLAGE, isAbledToBuildVillage);
	 * setWeightForAttr(instance, RetrievalHelper.IS_ABLED_TO_BUILD_ROAD,
	 * isAbledToBuildRoad); setWeightForAttr(instance,
	 * RetrievalHelper.IS_FIRST_TURN, isFirstTurn); setWeightForAttr(instance,
	 * RetrievalHelper.IS_SECOND_TURN, isSecondTurn); setWeightForAttr(instance,
	 * RetrievalHelper.IS_ALLOWED_TO_ROLL_DICE, isAllowedToRollDice);
	 * setWeightForAttr(instance, RetrievalHelper.IS_ABLED_TO_END_TURN,
	 * isAbledToEndTurn); //Hier wäre iscovered bool, mal gucken ob das geht
	 * setWeightForAttr(instance, RetrievalHelper.CITY_PLACES_ACTIVE,
	 * cityPlacesAct); setWeightForAttr(instance,
	 * RetrievalHelper.VILLAGE_PLACES_ACTIVE, villagePlacesAct);
	 * setWeightForAttr(instance, RetrievalHelper.ROAD_PLACES_ACTIVE,
	 * roadPlacesAct); //setWeightForAttr(instance,
	 * RetrievalHelper.HAS_LONGEST_ROAD, hasLongestRoad); setWeightForAttr(instance,
	 * RetrievalHelper.HAS_FREE_BUILD, hasFreeBuild); setWeightForAttr(instance,
	 * RetrievalHelper.HAS_FREE_BUILD_ROAD, hasFreeBuildRoad);
	 * /*setWeightForAttr(instance, RetrievalHelper.BRICKS, bricks);
	 * setWeightForAttr(instance, RetrievalHelper.WOOD, wood);
	 * setWeightForAttr(instance, RetrievalHelper.SHEEP, sheep);
	 * setWeightForAttr(instance, RetrievalHelper.WHEAT, wheat);
	 * setWeightForAttr(instance, RetrievalHelper.STONE, stone);
	 */

	/*
	 * jtf.setText(jtf.getText() +
	 * "\n*************************VERGLEICHSFALL**************************************"
	 * ); jtf.setText(jtf.getText() + "\nCityPlacesActive: " +
	 * instance.getAttForDesc(RetrievalHelper.CITY_PLACES_ACTIVE).getValueAsString()
	 * ); jtf.setText(jtf.getText() + "\nVillagePlacesActive: " +
	 * instance.getAttForDesc(RetrievalHelper.VILLAGE_PLACES_ACTIVE).
	 * getValueAsString()); jtf.setText(jtf.getText() + "\nRoadPlacesActive: " +
	 * instance.getAttForDesc(RetrievalHelper.ROAD_PLACES_ACTIVE).getValueAsString()
	 * ); jtf.setText(jtf.getText() + "\nFirst Tur: " +
	 * instance.getAttForDesc(RetrievalHelper.IS_FIRST_TURN).getValueAsString());
	 * jtf.setText(jtf.getText() + "\nSecond Turn: " +
	 * instance.getAttForDesc(RetrievalHelper.IS_SECOND_TURN).getValueAsString());
	 * jtf.setText(jtf.getText() + "\nFree Build: " +
	 * instance.getAttForDesc(RetrievalHelper.HAS_FREE_BUILD).getValueAsString());
	 * jtf.setText(jtf.getText() + "\nFree Build road: " +
	 * instance.getAttForDesc(RetrievalHelper.HAS_FREE_BUILD_ROAD).getValueAsString(
	 * )); jtf.setText(jtf.getText() + "\nhas longest Road: " +
	 * instance.getAttForDesc(RetrievalHelper.HAS_LONGEST_ROAD).getValueAsString());
	 * jtf.setText(jtf.getText() + "\nabled to build city: " +
	 * instance.getAttForDesc(RetrievalHelper.IS_ABLED_TO_BUILD_CITY).
	 * getValueAsString()); jtf.setText(jtf.getText() + "\nabled to build village: "
	 * + instance.getAttForDesc(RetrievalHelper.IS_ABLED_TO_BUILD_VILLAGE).
	 * getValueAsString()); jtf.setText(jtf.getText() + "\nabled to build road: " +
	 * instance.getAttForDesc(RetrievalHelper.IS_ABLED_TO_BUILD_ROAD).
	 * getValueAsString()); jtf.setText(jtf.getText() + "\nabled to end Turn: " +
	 * instance.getAttForDesc(RetrievalHelper.IS_ABLED_TO_END_TURN).getValueAsString
	 * ()); jtf.setText(jtf.getText() + "\nallowed to roll dice: " +
	 * instance.getAttForDesc(RetrievalHelper.IS_ALLOWED_TO_ROLL_DICE).
	 * getValueAsString()); /*jtf.setText(jtf.getText() + "\nbricks" +
	 * instance.getAttForDesc(RetrievalHelper.BRICKS).getValueAsString());
	 * jtf.setText(jtf.getText() + "\nwood" +
	 * instance.getAttForDesc(RetrievalHelper.WOOD).getValueAsString());
	 * jtf.setText(jtf.getText() + "\nsheep" +
	 * instance.getAttForDesc(RetrievalHelper.SHEEP).getValueAsString());
	 * jtf.setText(jtf.getText() + "\nwheat" +
	 * instance.getAttForDesc(RetrievalHelper.WHEAT).getValueAsString());
	 * jtf.setText(jtf.getText() + "\nstone" +
	 * instance.getAttForDesc(RetrievalHelper.STONE).getValueAsString());
	 */
	// jtf.setText(jtf.getText() + "\nPreference: " +
	// instance.getAttForDesc(RetrievalHelper.PREFERENCE_DESC).getValueAsString());

//			flush();

	// ----------------------------------------------------------------------------------------------------------------------

	public double SimOfOuery(Integer noun, Integer pluralnoun, String sentenceStructure, String keyword,
			String keyword2, String verb, String verb2, Integer caseNumber) {

		// similarity of the case
		double sim = 0;

		// create a new retrieval
		Retrieval ret = new Retrieval(myConcept, cb);
		// specify the retrieval method
		ret.setRetrievalMethod(RetrievalMethod.RETRIEVE_SORTED);
		// create a query instance
		Instance query = ret.getQueryInstance();

		SymbolDesc keywordDesc = (SymbolDesc) myConcept.getAllAttributeDescs().get("Keyword");
		SymbolDesc keyword2Desc = (SymbolDesc) myConcept.getAllAttributeDescs().get("Keyword2");
		SymbolDesc sentenceStructureDesc = (SymbolDesc) myConcept.getAllAttributeDescs().get("SentenceStructure");
		SymbolDesc verbDesc = (SymbolDesc) myConcept.getAllAttributeDescs().get("VerbType");
		SymbolDesc verb2Desc = (SymbolDesc) myConcept.getAllAttributeDescs().get("VerbType");
		IntegerDesc nomenDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("NumberNouns");
		IntegerDesc pluralnomenDesc = (IntegerDesc) myConcept.getAllAttributeDescs().get("NumberPluralNouns");

		// Insert values into the query
		query.addAttribute(keywordDesc, keywordDesc.getAttribute(keyword));
		query.addAttribute(keyword2Desc, keyword2Desc.getAttribute(keyword2));
		query.addAttribute(sentenceStructureDesc, sentenceStructureDesc.getAttribute(sentenceStructure));
		query.addAttribute(verbDesc, verbDesc.getAttribute(verb));
		query.addAttribute(verb2Desc, verb2Desc.getAttribute(verb2));

		try {
			query.addAttribute(nomenDesc, nomenDesc.getAttribute(noun));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		try {
			query.addAttribute(pluralnomenDesc, pluralnomenDesc.getAttribute(pluralnoun));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		// perform retrieval
		ret.start();
		// get the retrieval result
		List<Pair<Instance, Similarity>> result = ret.getResult();
		// get the case name
		if (result.size() > 0) {
			sim = result.get(caseNumber).getSecond().getValue();
			sim = Math.round(sim * 100.0);
			ArrayList<Hashtable<String, String>> liste = new ArrayList<Hashtable<String, String>>();
//			for (int i = 0; i < caseNumber; i++) {
			for (int i = 0; i < 5; i++) {
				liste.add(getAttributes(result.get(i), project.getConceptByID(engine.getConceptName())));
//				System.out.println("Fall: " + liste.get(i).toString());
			}
		} else {
			System.out.println("Retrieval Result is empty");
		}

		return sim;
	}

	/**
	 * This method delivers a Hashtable which contains the Attributs names
	 * (Attributes of the case) combined with their respective values.
	 * 
	 * @author weber,koehler,namuth
	 * @param r       = An Instance.
	 * @param concept = A Concept
	 * @return List = List containing the Attributes of a case with their values.
	 */
	public static Hashtable<String, String> getAttributes(Pair<Instance, Similarity> r, Concept concept) {

		Hashtable<String, String> table = new Hashtable<String, String>();
		ArrayList<String> cats = getCategories(r);
		// Add the similarity of the case
		table.put("Sim", String.valueOf(r.getSecond().getValue()));
		for (String cat : cats) {
			// Add the Attribute name and its value into the Hashtable
			table.put(cat, r.getFirst().getAttForDesc(concept.getAllAttributeDescs().get(cat)).getValueAsString());
		}
		return table;
	}

	/**
	 * This Method generates an ArrayList, which contains all Categories of aa
	 * Concept.
	 * 
	 * @author weber,koehler,namuth
	 * @param r = An Instance.
	 * @return List = List containing the Attributes names.
	 */
	public static ArrayList<String> getCategories(Pair<Instance, Similarity> r) {

		ArrayList<String> cats = new ArrayList<String>();

		// Read all Attributes of a Concept
		Set<AttributeDesc> catlist = r.getFirst().getAttributes().keySet();

		for (AttributeDesc cat : catlist) {
			if (cat != null) {
				// Add the String literals for each Attribute into the ArrayList
				cats.add(cat.getName());
			}
		}
		return cats;
	}

	public String displayAmalgamationFunctions() {

		ArrayList<String> amalgam = new ArrayList<String>();
		String listoffunctions = "Currently available Amalgamationfunctions: <br /> <br />";
		AmalgamationFct current = myConcept.getActiveAmalgamFct();
		System.out.println("Amalgamation Function is used = " + current.getName());
		List<AmalgamationFct> liste = myConcept.getAvailableAmalgamFcts();

		for (int i = 0; i < liste.size(); i++) {
//			System.out.println(liste.get(i).getName());
			listoffunctions = listoffunctions + liste.get(i).getName() + "<br />";
		}

		listoffunctions = listoffunctions
				+ (" <br /> <br /> Currently selected Amalgamationfunction: " + current.getName() + "\n");
		listoffunctions = listoffunctions
				+ (" <br /> <br /> Please type the name of the Amalgamationfunction to use in the "
						+ " Field \"Amalgamationfunction\" it will be automatically used during the next retrieval");
//		System.out.println(listoffunctions);	 s
		return listoffunctions;
	}
}